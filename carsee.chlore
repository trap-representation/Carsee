;    Carsee is an IRC client
;    Copyright (C) 2023  Somdipto Chakraborty
;
;    This program is free software: you can redistribute it and/or modify
;    it under the terms of the GNU General Public License as published by
;    the Free Software Foundation, either version 3 of the License, or
;    (at your option) any later version.
;
;    This program is distributed in the hope that it will be useful,
;    but WITHOUT ANY WARRANTY; without even the implied warranty of
;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;    GNU General Public License for more details.
;
;    You should have received a copy of the GNU General Public License
;    along with this program.  If not, see <https://www.gnu.org/licenses/>.

import "stdlib.chloreh"
import "io.chloreh"
import "socket.chloreh"
import "alloc2.chloreh"
import "stddef.chloreh"
import "string.chloreh"
import "watch.chloreh"
import "exit.chloreh"

:nickname_alloc_err
  pushp "\ncarsee (error): failed to allocate enough memory\n"
  pushp putstre call
  pushp phclean call
  pushi 1 hltr

:read_nickname_err
  pushp "\ncarsee (error): failed to read from input source\n"
  pushp putstre call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:trunc_nickname_err
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:pass_alloc_err
  pushp "\ncarsee (error): failed to allocate enough memory\n"
  pushp putstre call
  pop
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:read_pass_err
  pushp "\ncarsee (error): failed to read from input source\n"
  pushp putstre call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:trunc_pass_err
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:username_alloc_err
  pushp "\ncarsee (error): failed to allocate enough memory\n"
  pushp putstre call
  pop
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:read_username_err
  pushp "\ncarsee (error): failed to read from input source\n"
  pushp putstre call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:trunc_username_err
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:creat_socket_err
  pushp "\ncarsee (error): failed to create socket\n"
  pushp putstre call
  pop
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:host_alloc_err
  pushp "\ncarsee (error): failed to allocate enough memory\n"
  pushp putstre call
  pop
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:read_host_err
  pushp "\ncarsee (error): failed to read from input source\n"
  pushp putstre call
  pushp flush call
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:trunc_host_err
  pushp flush call
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:port_alloc_err
  pushp "\ncarsee (error): failed to allocate enough memory\n"
  pushp putstre call
  pop
  pushp flush call
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:read_port_err
  pushp "\ncarsee (error): failed to read from input source\n"
  pushp putstre call
  pushp flush call
  pushp flush call
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:trunc_port_err
  pushp flush call
  pushp flush call
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:connect_err
  pushp "\ncarsee (error): failed to connect\n"
  pushp putstre call
  pushp flush call
  pushp flush call
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:pass_send_err
  pushp "\ncarsee (error): failed to send message to server\n"
  pushp putstre call
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:nick_send_err
  pushp "\ncarsee (error): failed to send message to server\n"
  pushp putstre call
  get2 pushp closef call
  pushp flush call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:user_send_err
  pushp "\ncarsee (error): failed to send message to server\n"
  pushp putstre call
  get2 pushp closef call
  pushp flush call
  pushp phclean call
  pushi 1 hltr

:msg_alloc_err
  pushp "\ncarsee (error): failed to allocate enough memory\n"
  pushp putstre call
  get2 pushp closef call
  pushp phclean call
  pushi 1 hltr

:creat_watch_err
  pushp "\ncarsee (error): failed to create watch\n"
  pushp putstre call
  pop
  pushp flush call
  get2 pushp closef call
  pushp phclean call
  pushi 1 hltr

:watch_err
  pushp "\ncarsee (error): failed to read from input source\n"
  pushp putstre call
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr

:climsg_read_err
  pushp "\ncarsee (error): failed to read from input source\n"
  pushp putstre call
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr

:trunc_climsg_err
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr


:test_reply_err
  pushp "\ncarsee (error): failed to reply to test\n"
  pushp putstre call
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr

:climsg_preview_err
  pushp "\ncarsee (error): failed to display message preview\n"
  pushp putstre call
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr

:climsg_send_err
  pushp "\ncarsee (error): failed to send message to server\n"
  pushp putstre call
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr

:recv_serv_err
  pushp "\ncarsee (error): failed to receive message from server\n"
  pushp putstre call
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr

:servmsg_write_err
  pushp "\ncarsee (error): failed to display servent-sent message\n"
  pushp putstre call
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr

:pong_send_err
  pushp "\ncarsee (error): failed to send message to server\n"
  pushp putstre call
  pop
  pushp flush call
  get2 pushp closef call
  get3 pushp watch_close call
  pushp phclean call
  pushi 1 hltr

:quit
  pushp "\ncarsee (info): quitting\n" pushp putstre call
  pushp flush call
  pushp phclean call
  get2 pushp closef call
  get3 pushp watch_close call
  hlt

set MSG_LEN 512
set MSG_LEN1 511
set MSG_LEN2 510

:consume_input_if_too_large                                ;this subroutine truncates messages received
                                                           ;from the input source if they're > 510 bytes
                                                           ;it also replaces the newline (if any) at the
                                                           ;end of the source buffer with a null terminator
  ;stack state: buf size return
  swap write0
  swap
  get0
  addp
  dup loadc pushc '\n' pushp skip_consume jeq
  pushp init_loop_consume jmp

  :skip_consume
    pushc '\0' swap storec
    pushi 0
    swap
    ret

  :init_loop_consume
    pop

    :loop_consume
      pushp getchar call
      dup pushi EOF pushp end_consume jeq
      dup pushi '\n' pushp end_consume jeq
      pushi 0 pushp end_consume_err jgt
      pushp loop_consume jmp

      :end_consume
        pushp "\ncarsee (info): message truncated\n"
        pushp putstre call
        pop
        pushi 0
        swap
        ret

      :end_consume_err
        pushp "\ncarsee (error): failed to read from input source\n"
        pushp putstre call
        pop
        pushi 1
        swap
        ret

:main
  pushp "\
carsee (info): Carsee is an IRC client\n\
carsee (info): Copyright (C) 2023  Somdipto Chakraborty\n\
carsee (info): \n\
carsee (info): This program is free software: you can redistribute it and/or modify\n\
carsee (info): it under the terms of the GNU General Public License as published by\n\
carsee (info): the Free Software Foundation, either version 3 of the License, or\n\
carsee (info): (at your option) any later version.\n\
carsee (info): \n\
carsee (info): This program is distributed in the hope that it will be useful,\n\
carsee (info): but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
carsee (info): MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
carsee (info): GNU General Public License for more details.\n\
carsee (info): \n\
carsee (info): You should have received a copy of the GNU General Public License\n\
carsee (info): along with this program.  If not, see <https://www.gnu.org/licenses/>.\n"
  pushp putstre call

  :connect_serv

    pushp "\ncarsee (info): Nickname\n"
    pushp putstre call

    pushl MSG_LEN1 pushp aseg call                         ;chunk to store the username
    get0 pushp nickname_alloc_err jnz

    pushl MSG_LEN2
    over
    pushp getstr call
    get0 pushi EOF pushp read_nickname_err jeq
    get0 write3                                            ;length of nickname

    dup get0 pushp consume_input_if_too_large call
    pushp trunc_nickname_err jnz

    pushp "\ncarsee (info): Password\n"
    pushp putstre call

    pushl MSG_LEN1 pushp aseg call                         ;chunk to store the password
    get0 pushp pass_alloc_err jnz

    pushl MSG_LEN2
    over
    pushp getstr call
    get0 pushi EOF pushp read_pass_err jeq
    get0 write4                                            ;length of password

    dup get0 pushp consume_input_if_too_large call
    pushp trunc_pass_err jnz

    pushp "\ncarsee (info): Username\n"
    pushp putstre call

    pushl MSG_LEN1 pushp aseg call                         ;chunk to store the username
    get0 pushp username_alloc_err jnz

    pushl MSG_LEN2
    over
    pushp getstr call
    get0 pushi EOF pushp read_username_err jeq
    get0 write5                                            ;length of username

    dup get0 pushp consume_input_if_too_large call
    pushp trunc_username_err jnz

    pushi AF_INET
    pushi SOCK_STREAM
    pushi 0
    pushp socket call                                      ;the sd
    get0 pushi -1 pushp creat_socket_err jeq

    write2                                                 ;save the sd in block 2

    pushp "\ncarsee (info): Host\n"
    pushp putstre call

    pushl MSG_LEN1 pushp aseg call                         ;chunk to store the host
    get0 pushp host_alloc_err jnz

    pushl MSG_LEN2
    over
    pushp getstr call
    get0 pushi EOF pushp read_host_err jeq

    dup get0 pushp consume_input_if_too_large call
    pushp trunc_host_err jnz

    pushp "\ncarsee (info): Port\n"
    pushp putstre call

    pushl MSG_LEN1 pushp aseg call                         ;chunk to store the port
    get0 pushp port_alloc_err jnz

    pushl MSG_LEN2
    over
    pushp getstr call
    get0 pushi EOF pushp read_port_err jeq

    dup get0 pushp consume_input_if_too_large call
    pushp trunc_port_err jnz

    over
    over
    swap
    pushi AF_INET
    pushi SOCK_STREAM
    pushi 0
    pushi 0
    get2
    pushp connect call
    get0 pushp connect_err jnz

    pushp "\ncarsee (info): connection successful\n" pushp putstre call

    pushp flush call
    pushp flush call

    ;stack state: nickname password username
    swap

    get2
    pushp "PASS "
    pushui 5
    pushp writef call                                      ;write to socket
    get0 pushi -1 pushp pass_send_err jeq

    get2
    over
    get4
    pushp writef call
    get0 pushi -1 pushp pass_send_err jeq

    get2
    pushp "\r\n"
    pushui 2
    pushp writef call
    get0 pushi -1 pushp pass_send_err jeq

    pushp flush call

    swap

    get2
    pushp "NICK "
    pushui 5
    pushp writef call                                      ;write to socket
    get0 pushi -1 pushp nick_send_err jeq

    get2
    over
    get3
    pushp writef call
    get0 pushi -1 pushp nick_send_err jeq

    get2
    pushp "\r\n"
    pushui 2
    pushp writef call
    get0 pushi -1 pushp nick_send_err jeq

    pushp flush call

    get2
    pushp "USER "
    pushui 5
    pushp writef call                                      ;write to socket
    get0 pushi -1 pushp user_send_err jeq

    get2
    over
    get5
    pushp writef call
    get0 pushi -1 pushp user_send_err jeq

    get2
    pushp "\r\n"
    pushui 2
    pushp writef call
    get0 pushi -1 pushp user_send_err jeq

    pushp flush call

    pushl MSG_LEN pushp aseg call
    get0 pushp msg_alloc_err jnz

    pushp watch_new call
    dup pushi -1 pushp creat_watch_err jeq
    write3                                                 ;save the wd in block 3

    pushi 2 write5                                         ;it is used during "PING" for executing behavior similar to
                                                           ;that of a state machine based on different values in block 5

    pushi 0 write6                                         ;if it's set to a non-zero value, the output is "held"

    pushi 0 write7                                         ;if it's set to a non-zero value, the socket is no
                                                           ;longer accessible

    :loop
      get6 pushp unhold jnz

      pushp unheld jmp

      :unhold
        pushp "\ncarsee (info): unheld\n" pushp putstre call
        pushi 0 write6

      :unheld
        get3
        pushi READFD
        pushp fd_zero call

        pushi STDIN
        get3
        pushi READFD
        pushp fd_set call

        get2
        get3
        pushi READFD
        pushp fd_set call

        get3
        pushi 0
        pushi -1
        pushi -1
        get2 pushi 1 addi
        pushp watch call
        get0 pushi -1 pushp watch_err jeq

        get2
        get3
        pushi READFD
        pushp fd_isset call
        pushp recv_serv jnz

        pushi STDIN
        get3
        pushi READFD
        pushp fd_isset call
        pushp read_input_source jnz

        :read_input_source
          pushl MSG_LEN2
          over
          pushp getstr call
          get0 pushi EOF pushp climsg_read_err jeq
          get0 write4                                      ;length of message

          dup get0 pushp consume_input_if_too_large call
          pushp trunc_climsg_err jnz

          get4 get7 addi pushp loop jz

          dup pushp "/quit" pushp strcmp call pushp quit jz
          dup pushp "/cconnect" pushp strcmp call pushp idc_connect_serv jz
          dup pushp "/test" pushp strcmp call pushp test jz
          dup pushp "/help" pushp strcmp call pushp help jz
          dup pushp "/status" pushp strcmp call pushp status jz
          get7 pushp read_input_source jnz
          dup pushp "/hold" pushp strcmp call pushp hold jz
          pushp continue_to_preview jmp

          :status
            get7 pushp status_connected jz
            pushp status_not_connected jmp

            :status_not_connected
              pushp "\ncarsee (info): server has closed connection\n"
              pushp putstre call
              pushp read_input_source jmp

            :status_connected
              pushp "\ncarsee (info): server has NOT closed connection\n"
              pushp putstre call
              pushp loop jmp

          :test
            pushp "\ncarsee (info): passed\n"
            pushp putstre call
            get0 pushi EOF pushp test_reply_err jeq
            get7 pushp read_input_source jnz
            pushp loop jmp

          :help
            pushp "\n\
carsee (info): /quit: close client\n\
carsee (info): /hold (i): pauses all operations until at least one character is received from the input source\n\
carsee (info): /cconnect: connects to a (possibly different) server\n\
carsee (info): /test: replies with a \"passed\" message\n\
carsee (info): /status: displays the connection status of the server\n\
carsee (info): /help: displays this help message\n\
carsee (info): ---\n\
carsee (info): commands suffixed with \" (i)\" are ignored once the server closes connection\n"
            pushp putstre call
            pushp loop jmp

          :idc_connect_serv
            pushp flush call
            get2 pushp closef call
            get3 pushp watch_close call
            pushp connect_serv jmp

          :hold
            pushp "\ncarsee (info): held\n" pushp putstre call
            pushi 1 write6
            pushp read_input_source jmp

          :continue_to_preview
            pushp "\ncarsee (preview): " pushp putstre call
            get0 pushi EOF pushp climsg_preview_err jeq

            pushi STDERR
            over
            get4 ;message length
            pushp writef call
            get0 pushi -1 pushp climsg_preview_err jeq

            pushp "\n" pushp putstre call
            get0 pushi EOF pushp climsg_preview_err jeq

            get2
            over
            get4 ;message length
            pushp writef call
            get0 pushi -1 pushp climsg_send_err jeq

            get2
            pushp "\r\n"
            pushi 2
            pushp writef call
            get0 pushi -1 pushp climsg_send_err jeq

            pushp loop jmp

        :recv_serv
          get2
          over ;allocated chunk
          pushl MSG_LEN
          pushp readf call
          get0 pushi -1 pushp recv_serv_err jeq
          get0 write3

          get3 pushp serv_closed_connection jz
          pushp continue_servmsg_write jmp

          :serv_closed_connection
            pushp "\ncarsee (info): server closed connection\n"
            pushp putstre call
            pushi 1 write7
            pushp read_input_source jmp

          :continue_servmsg_write
            pushi STDERR
            over
            get3
            pushp writef call
            get0 pushi -1 pushp servmsg_write_err jeq

            dup

            :check_ping
              get5 pushi 0 pushp check_ssr jeq
              get5 pushi 1 pushp check_ssn jeq
              get5 pushi 2 pushp check_P jeq
              get5 pushi 3 pushp check_I jeq
              get5 pushi 4 pushp check_N jeq
              get5 pushi 5 pushp check_G jeq
              get5 pushi 6 pushp check_esr jeq
              get5 pushi 7 pushp check_esn jeq

              :inc_b5
                pushi 1 get5 addi write5
                pushp continue_checking_ping jmp

              :continue_checking_ping
                pushi 1 addp
                pushi 1 get3 subl dup write3
                pushp check_ping jnz
                pop
                pushp loop jmp

              :check_ssr
                pushc '\r' over loadc pushp inc_b5 jeq
                pushp continue_checking_ping jmp

              :check_ssn
                pushc '\n' over loadc pushp inc_b5 jeq
                pushi 0 write5
                pushp continue_checking_ping jmp

              :check_P
                pushc 'P' over loadc pushp inc_b5 jeq
                pushi 0 write5
                pushp continue_checking_ping jmp

              :check_I
                pushc 'I' over loadc pushp inc_b5 jeq
                pushi 0 write5
                pushp check_P jmp

              :check_N
                pushc 'N' over loadc pushp inc_b5 jeq
                pushi 0 write5
                pushp check_P jmp

              :check_G
                pushc 'G' over loadc pushp send_pong jeq
                pushi 0 write5
                pushp check_P jmp

                :send_pong
                  pushi 6 write5

                  get2
                  pushp "PONG"
                  pushi 4
                  pushp writef call
                  get0 pushi -1 pushp pong_send_err jeq

                  pushp continue_checking_ping jmp

              :check_esr
                get2
                over
                pushi 1
                pushp writef call
                get0 pushi -1 pushp pong_send_err jeq

                pushc '\r' over loadc pushp inc_b5 jeq

                pushp continue_checking_ping jmp

              :check_esn
                pushi 6 write5

                get2
                over
                pushi 1
                pushp writef call
                get0 pushi -1 pushp pong_send_err jeq

                pushc '\n' over loadc pushp end_pong_msg jeq

               pushp continue_checking_ping jmp

                :end_pong_msg
                  pushi 2 write5
                  pushp continue_checking_ping jmp
